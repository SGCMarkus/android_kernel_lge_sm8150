# SPDX-License-Identifier: GPL-2.0
#
# kbuild file for firmware/
#

# Create $(fwabs) from $(CONFIG_EXTRA_FIRMWARE_DIR) -- if it doesn't have a
# leading /, it's relative to $(srctree).
fwdir := $(subst $(quote),,$(CONFIG_EXTRA_FIRMWARE_DIR))
fwabs := $(addprefix $(srctree)/,$(filter-out /%,$(fwdir)))$(filter /%,$(fwdir))

fw-external-y := $(subst $(quote),,$(CONFIG_EXTRA_FIRMWARE))

ifdef CONFIG_LGE_TOUCH_FW_PATH
fwpath := $(subst ",,$(CONFIG_LGE_TOUCH_FW_PATH))
ifdef CONFIG_LGE_TOUCH_MODULE_DETECT
lge_touch_image_files := $(wildcard $(srctree)/firmware/$(fwpath)/*/*/*)
else
lge_touch_image_files := $(wildcard $(srctree)/firmware/$(fwpath)/*)
endif
lge_touch_firmware := $(subst $(srctree)/firmware/,,$(lge_touch_image_files))
fw-shipped-$(CONFIG_LGE_TOUCH_CORE_BASE) += $(lge_touch_firmware)
endif

fw-shipped-$(CONFIG_FPGA_MGR_ICE40_SPI_LGE) += lattice/rev02/lg_singlewire_m48_impl_1.img
fw-shipped-$(CONFIG_FPGA_MGR_ICE40_SPI_LGE) += lattice/revA/lg_singlewire_m48_impl_1.img
fw-shipped-$(CONFIG_FPGA_MGR_ICE40_SPI_LGE) += lattice/lg_singlewire_m48_impl_1.img
fw-shipped-$(CONFIG_FPGA_MGR_ICE40_SPI_LGE) += lattice/lg_singlewire_s48_impl_1.img

fw-shipped-$(CONFIG_FPGA_MGR_ICE40_SPI_LGE) += mcu/FLASH_SYSTEM.img

ifdef CONFIG_MACH_SM8150_ALPHA
fw-shipped-$(CONFIG_SAR_ATMF04_12QFN) += atmf04/atmf04_2CH_V0.37.fw
else
fw-shipped-$(CONFIG_SAR_ATMF04_12QFN) += atmf04/ALMF04_Sar2CH_V1.38T.fw
fw-shipped-$(CONFIG_SAR_ATMF04_F37) += atmf04/atmf04_2CH_V0.37.fw
endif
fw-shipped-all := $(fw-shipped-y) $(fw-shipped-m) $(fw-shipped-)

# Directories which we _might_ need to create, so we have a rule for them.
firmware-dirs := $(sort $(addprefix $(objtree)/$(obj)/,$(dir $(fw-external-y) $(fw-shipped-all))))

quiet_cmd_copy  = COPY    $@
      cmd_copy  = cp $(srctree)/$@ $@

quiet_cmd_fwbin = MK_FW   $@
      cmd_fwbin = FWNAME="$(patsubst firmware/%.gen.S,%,$@)";		     \
		  FWSTR="$(subst /,_,$(subst .,_,$(subst -,_,$(patsubst	     \
				firmware/%.gen.S,%,$@))))";		     \
		  ASM_WORD=$(if $(CONFIG_64BIT),.quad,.long);		     \
		  ASM_ALIGN=$(if $(CONFIG_64BIT),3,2);			     \
		  PROGBITS=$(if $(CONFIG_ARM),%,@)progbits;		     \
		  echo "/* Generated by firmware/Makefile */"		> $@;\
		  echo "    .section .rodata"				>>$@;\
		  echo "    .p2align 4"					>>$@;\
		  echo "_fw_$${FWSTR}_bin:"				>>$@;\
		  echo "    .incbin \"$(2)\""				>>$@;\
		  echo "_fw_end:"					>>$@;\
		  echo "   .section .rodata.str,\"aMS\",$${PROGBITS},1"	>>$@;\
		  echo "    .p2align $${ASM_ALIGN}"			>>$@;\
		  echo "_fw_$${FWSTR}_name:"				>>$@;\
		  echo "    .string \"$$FWNAME\""			>>$@;\
		  echo "    .section .builtin_fw,\"a\",$${PROGBITS}"	>>$@;\
		  echo "    .p2align $${ASM_ALIGN}"			>>$@;\
		  echo "    $${ASM_WORD} _fw_$${FWSTR}_name"		>>$@;\
		  echo "    $${ASM_WORD} _fw_$${FWSTR}_bin"		>>$@;\
		  echo "    $${ASM_WORD} _fw_end - _fw_$${FWSTR}_bin"	>>$@;

# One of these files will change, or come into existence, whenever
# the configuration changes between 32-bit and 64-bit. The .S files
# need to change when that happens.
wordsize_deps := $(wildcard include/config/64bit.h include/config/32bit.h \
		include/config/ppc32.h include/config/ppc64.h \
		include/config/superh32.h include/config/superh64.h \
		include/config/x86_32.h include/config/x86_64.h \
		firmware/Makefile)

# Workaround for make < 3.81, where .SECONDEXPANSION doesn't work.
# It'll end up depending on these targets, so make them a PHONY rule which
# depends on _all_ the directories in $(firmware-dirs), and it'll work out OK.
PHONY += $(objtree)/$$(%) $(objtree)/$(obj)/$$(%)
$(objtree)/$$(%) $(objtree)/$(obj)/$$(%): $(firmware-dirs)
	@true
# For the $$(dir %) trick, where we need % to be expanded first.
.SECONDEXPANSION:
ifneq ($(objtree),$(srctree))
$(patsubst %,$(obj)/%, $(fw-shipped-y)): %: %.gen.S
	$(call cmd,copy)
endif

$(patsubst %,$(obj)/%.gen.S, $(fw-shipped-y)): %: $(wordsize_deps) \
		| $(objtree)/$$(dir %)
	$(call cmd,fwbin,$(patsubst %.gen.S,%,$@))
$(patsubst %,$(obj)/%.gen.S, $(fw-external-y)): %: $(wordsize_deps) \
		include/config/extra/firmware/dir.h
	$(call cmd,fwbin,$(fwabs)/$(patsubst $(obj)/%.gen.S,%,$@))

# The .o files depend on the binaries directly; the .S files don't.
$(patsubst %,$(obj)/%.gen.o, $(fw-shipped-y)): %.gen.o: %
$(patsubst %,$(obj)/%.gen.o, $(fw-external-y)): $(obj)/%.gen.o: $(fwdir)/%

obj-y				 += $(patsubst %,%.gen.o, $(fw-external-y))
obj-$(CONFIG_FIRMWARE_IN_KERNEL) += $(patsubst %,%.gen.o, $(fw-shipped-y))

ifeq ($(KBUILD_SRC),)
# Makefile.build only creates subdirectories for O= builds, but external
# firmware might live outside the kernel source tree
_dummy := $(foreach d,$(addprefix $(obj)/,$(dir $(fw-external-y))), $(shell [ -d $(d) ] || mkdir -p $(d)))
endif

targets := $(patsubst $(obj)/%,%, \
                                $(shell find $(obj) -name \*.gen.S 2>/dev/null))
# Without this, built-in.o won't be created when it's empty, and the
# final vmlinux link will fail.
obj- := dummy
